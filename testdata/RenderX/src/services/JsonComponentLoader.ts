/**
 * JSON Component Loader Service
 *
 * Dynamically discovers and loads JSON components from the public/json-components folder
 * and provides them to the Element Library for display.
 *
 * This service is purely data-driven with no hard-coded knowledge of component files.
 * It uses multiple discovery strategies:
 * 1. Loads from index.json if available (fastest)
 * 2. Falls back to discovering components by trying common component names
 * 3. Verifies all discovered files are actually loadable
 */

import type { JsonComponent, LoadedJsonComponent, JsonComponentLoadResult } from '../types/JsonComponent';
import { MusicalSequences } from '../communication';

export class JsonComponentLoader {
  private loadedComponents: LoadedJsonComponent[] = [];
  private loadingPromise: Promise<JsonComponentLoadResult> | null = null;
  private conductor: any = null;

  /**
   * Connect to the musical conductor for sequence-based loading
   * @param conductor - The musical conductor instance
   */
  connectToConductor(conductor: any): void {
    this.conductor = conductor;
    console.log('üéº JsonComponentLoader: Connected to musical conductor');
  }

  /**
   * Load all JSON components using musical sequences
   */
  async loadAllComponentsMusical(): Promise<JsonComponentLoadResult> {
    if (!this.conductor) {
      console.warn('üö® JsonComponentLoader: No conductor connected, falling back to direct loading');
      return this.loadAllComponents();
    }

    // Discover component files dynamically first
    const componentFiles = await this.getComponentFiles();

    // Start JSON component loading sequence with discovered files
    const sequenceId = MusicalSequences.startJsonComponentLoadingFlow(
      this.conductor,
      componentFiles, // Dynamically discovered component files
      {
        validateStructure: true,
        autoRegister: true,
        errorHandling: 'continue'
      }
    );

    console.log(`üéº JsonComponentLoader: Started musical loading sequence ${sequenceId} for ${componentFiles.length} components`);

    // Still perform the actual loading (the sequence handles events)
    return this.performLoad();
  }

  /**
   * Load all JSON components from the public/json-components folder (legacy method)
   */
  async loadAllComponents(): Promise<JsonComponentLoadResult> {
    // Return existing promise if already loading
    if (this.loadingPromise) {
      return this.loadingPromise;
    }

    this.loadingPromise = this.performLoad();
    const result = await this.loadingPromise;
    this.loadingPromise = null;

    return result;
  }

  /**
   * Get all loaded components
   */
  getLoadedComponents(): LoadedJsonComponent[] {
    return [...this.loadedComponents];
  }

  /**
   * Get components by category
   */
  getComponentsByCategory(category: string): LoadedJsonComponent[] {
    return this.loadedComponents.filter(comp => comp.metadata.category === category);
  }

  /**
   * Get all unique categories
   */
  getCategories(): string[] {
    const categories = new Set(this.loadedComponents.map(comp => comp.metadata.category));
    return Array.from(categories).sort();
  }

  /**
   * Find component by type
   */
  findComponentByType(type: string): LoadedJsonComponent | undefined {
    return this.loadedComponents.find(comp => comp.metadata.type === type);
  }

  /**
   * Clear all loaded components
   */
  clearComponents(): void {
    this.loadedComponents = [];
  }

  /**
   * Generate component index data for debugging/maintenance
   * This can help create or update the index.json file
   */
  generateComponentIndex(): any {
    const categories = this.getCategories();
    const componentFilenames = this.loadedComponents.map(comp => comp.filename);

    return {
      version: "1.0.0",
      description: "Index of available JSON components for RenderX Evolution",
      lastUpdated: new Date().toISOString().split('T')[0],
      components: componentFilenames.sort(),
      metadata: {
        totalComponents: componentFilenames.length,
        categories: categories,
        autoGenerated: true,
        notes: "This index was auto-generated from loaded components. Copy this data to /json-components/index.json for faster startup."
      }
    };
  }

  /**
   * Log the current component index for debugging
   */
  logComponentIndex(): void {
    const index = this.generateComponentIndex();
    console.log('üìã Current Component Index:', JSON.stringify(index, null, 2));
  }

  /**
   * Perform the actual loading of components
   */
  private async performLoad(): Promise<JsonComponentLoadResult> {
    const result: JsonComponentLoadResult = {
      success: [],
      failed: []
    };

    try {
      // Get list of JSON files in the json-components directory
      const componentFiles = await this.getComponentFiles();
      
      console.log(`üîç Found ${componentFiles.length} JSON component files to load`);

      // Load each component file
      for (const filename of componentFiles) {
        try {
          const component = await this.loadSingleComponent(filename);
          result.success.push(component);
          console.log(`‚úÖ Loaded JSON component: ${component.metadata.name} (${filename})`);
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : 'Unknown error';
          result.failed.push({ filename, error: errorMessage });
          console.error(`‚ùå Failed to load JSON component ${filename}:`, errorMessage);
        }
      }

      // Update internal state
      this.loadedComponents = result.success;

      console.log(`üéº JSON Component loading complete: ${result.success.length} loaded, ${result.failed.length} failed`);
      
    } catch (error) {
      console.error('‚ùå Failed to load JSON components:', error);
      result.failed.push({
        filename: 'directory-scan',
        error: error instanceof Error ? error.message : 'Failed to scan directory'
      });
    }

    return result;
  }

  /**
   * Get list of JSON component files dynamically
   * Uses multiple discovery strategies to find all available JSON components
   */
  private async getComponentFiles(): Promise<string[]> {
    console.log('üîç JsonComponentLoader: Starting dynamic component discovery...');

    const discoveredFiles: string[] = [];

    // Strategy 1: Try to load a components index file if it exists
    try {
      const indexResponse = await fetch('/json-components/index.json');
      if (indexResponse.ok) {
        const indexData = await indexResponse.json();
        if (Array.isArray(indexData.components)) {
          console.log('üìã Found components index file with', indexData.components.length, 'components');
          discoveredFiles.push(...indexData.components);
        }
      }
    } catch (error) {
      console.log('üìã No components index file found, using discovery strategies');
    }

    // Strategy 2: If no index file, try common component names
    if (discoveredFiles.length === 0) {
      const commonComponentNames = [
        'button', 'input', 'text', 'textarea', 'select', 'checkbox', 'radio',
        'image', 'link', 'div', 'span', 'paragraph', 'heading', 'label',
        'form', 'table', 'list', 'card', 'modal', 'dropdown', 'slider',
        'progress', 'spinner', 'alert', 'badge', 'tooltip', 'accordion',
        'tabs', 'breadcrumb', 'pagination', 'navbar', 'sidebar', 'footer',
        'header', 'section', 'article', 'aside', 'main', 'container'
      ];

      console.log('üîç Attempting to discover components by trying common names...');

      for (const componentName of commonComponentNames) {
        const filename = `${componentName}.json`;
        try {
          const response = await fetch(`/json-components/${filename}`, { method: 'HEAD' });
          if (response.ok) {
            discoveredFiles.push(filename);
            console.log(`‚úÖ Discovered component: ${filename}`);
          }
        } catch (error) {
          // Silently continue - this is expected for non-existent files
        }
      }
    }

    // Strategy 3: Verify all discovered files are actually loadable
    const verifiedFiles: string[] = [];

    for (const filename of discoveredFiles) {
      try {
        const response = await fetch(`/json-components/${filename}`, { method: 'HEAD' });
        if (response.ok) {
          verifiedFiles.push(filename);
        } else {
          console.warn(`‚ö†Ô∏è Component file ${filename} listed but not accessible`);
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è Component file ${filename} verification failed:`, error);
      }
    }

    console.log(`üéØ Component discovery complete: ${verifiedFiles.length} components found`);
    return verifiedFiles;
  }

  /**
   * Load a single JSON component file
   */
  private async loadSingleComponent(filename: string): Promise<LoadedJsonComponent> {
    const response = await fetch(`/json-components/${filename}`);
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    const jsonData = await response.json();
    
    // Validate the JSON structure
    this.validateJsonComponent(jsonData, filename);
    
    // Create loaded component with metadata
    const loadedComponent: LoadedJsonComponent = {
      ...jsonData,
      id: this.generateComponentId(jsonData.metadata.type, filename),
      filename,
      loadedAt: new Date()
    };

    return loadedComponent;
  }

  /**
   * Validate JSON component structure
   */
  private validateJsonComponent(data: any, filename: string): asserts data is JsonComponent {
    if (!data || typeof data !== 'object') {
      throw new Error('Invalid JSON: not an object');
    }

    if (!data.metadata || !data.metadata.type || !data.metadata.name) {
      throw new Error('Invalid JSON: missing required metadata (type, name)');
    }

    if (!data.ui || !data.ui.template) {
      throw new Error('Invalid JSON: missing required UI template');
    }

    if (!data.integration || !data.integration.properties) {
      throw new Error('Invalid JSON: missing required integration properties');
    }
  }

  /**
   * Generate unique component ID
   */
  private generateComponentId(type: string, filename: string): string {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substr(2, 5);
    return `json-${type}-${timestamp}-${random}`;
  }
}

// Export singleton instance
export const jsonComponentLoader = new JsonComponentLoader();
